# 快速开始single-spa
Getting Started with single-spa
JavaScript微前端
## JavaScript microfrontends
Join the chat on Slack
single-spa is a framework for bringing together multiple javascript microfrontends in a frontend application. Architecting your frontend using single-spa enables many benefits, such as:
Use [multiple frameworks](https://single-spa.js.org/docs/ecosystem/) on the same page [without page refreshing](https://single-spa.js.org/docs/building-applications/) ([React](https://single-spa.js.org/docs/ecosystem-react/), AngularJS, Angular, Ember, or whatever you're using)
Deploy your microfrontends independently.
Write code using a new framework, without rewriting your existing app
Lazy load code for improved initial load time.

加入Slack上的聊天，定制更新通知。
single-spa是一个框架，用于将多个javascript微前端整合到一个前端应用程序中。使用single-spa架构前端可以带来很多好处，比如:
●	在同一个页面上使用多个框架，而不需要页面刷新(React、AngularJS、Angular、Ember，或任何你正在使用的框架)
●	独立部署微前端
●	使用新的框架编写代码，而不必重写现有的应用程序
●	延迟加载代码，改善初始加载时间
示例
# Demos and examples
See our examples page.
查看示例
体系结构概述
# Architectural Overview
single-spa takes inspiration from modern framework component lifecycles by applying lifecycles to entire applications. It was born out of Canopy's desire to use React + react-router instead of being forever stuck with our AngularJS + ui-router application, and now single-spa supports almost any framework. Since JavaScript is notorious for the short-life of its many frameworks, we decided to make it easy to use whichever frameworks you want.
single-spa apps consist of the following:
1.Applications, each of which is an entire SPA itself (sort of). Each application can respond to url routing events and must know how to bootstrap, mount, and unmount themselves from the DOM. The main difference between a traditional SPA and single-spa applications is that they must be able to coexist with other applications, and they do not each have their own html page.
For example, your React or Angular SPAs are applications. When active, they listen to url routing events and put content on the DOM. When inactive, they do not listen to url routing events and are totally removed from the DOM.
2.A single-spa-config, which is the html page and the JavaScript that registers applications with single-spa. Each application is registered with three things:
A name
A function to load the application's code
A function that determines when the application is active/inactive
single-spa通过将生命周期应用于整个应用程序，从现代框架组件生命周期中获得灵感。它诞生于Canopy对React + react-router的渴望，而不是永远停留在AngularJS + ui-router应用程序上，现在single-spa几乎可以支持任何框架。由于JavaScript因其众多框架的短命而臭名昭著，所以我们决定让您可以轻松地使用任何您想要的框架。
single-spa app由以下几个部分组成:
1. 应用程序applications，每一个应用本身就是一个完整的SPA(某种程度上)。每个应用程序都可以响应url路由事件，并且必须清楚如何从DOM上初始化、挂载和卸载它们自己。传统SPA和single-SPA应用程序之间的主要区别是：single-SPA应用必须能够与其他应用程序共存，并且它们没有各自的html页面。
例如，您的React或Angular SPAs就是应用程序。当激活时，它们监听url路由事件并将内容放到DOM上。当处于非激活状态时，它们不侦听url路由事件，并完全从DOM中删除。
2. 一个single-spa配置，它是用single-spa注册应用程序的html页面和JavaScript。每个申请都要注册以下三个参数:
○ 一个名称
〇 加载应用程序代码的函数
〇 确定应用程序何时处于激活/非激活状态的函数
推荐设置
# The Recommended Setup
The single-spa core team has put together documentation, tools, and videos showing the currently encouraged best practices with single-spa. Check out these docs for more information.
single-spa核心团队已经将文档、工具和视频整合在一起，展示了当前使用single-spa所鼓励的最佳实践。查看这些文档以获得更多信息。
single-spa上手难吗？
# How hard will it be to use single-spa?
single-spa works with ES5, ES6+, TypeScript, Webpack, SystemJS, Gulp, Grunt, Bower, ember-cli, or really any build system available. You can npm install it, jspm install it, or even just use a <script> tag if you prefer.
Our objective is to make using single-spa as easy as possible. But we should also point out that this is an advanced architecture that is different from how front-end applications are typically done.
If you're not starting your application from scratch, you'll have to migrate your SPA to become a single-spa application.
React - Migrating to single-spa
AngularJS - Migrating to single-spa
single-spa works in Chrome, Firefox, Safari, IE11, and Edge.
single-spa适用于ES5、ES6+、TypeScript、Webpack、SystemJS、Gulp、Grunt、Bower、ember-cli，或者任何可用的构建系统。您可以npm安装它，jspm安装它，如果您愿意，甚至可以使用`<script>`标签引入。
我们的目标是让大家使用single-spa尽可能简单易用。但我们也应该指出，这是一个先进的架构，这与前端应用程序通常的工作方式不同。
如果您一开始不是使用single-spa的应用程序，您将不得不将您的SPA迁移为一个single-SPA应用程序，以下提供了一些迁移示例：
●  React —	 迁移到single-spa
●  AngularJS - 迁移到single-spa
single-spa适用于Chrome、Firefox、Safari、IE11和Edge。
single-spa是不是一个重复的名称呢?
# Isn't single-spa sort of a redundant name?
Yep.
是的，双重强调。

文档介绍
# Documentation
The documentation is divided into several sections:
Getting Started
single-spa Applications
single-spa Parcels
Examples
Ecosystem
Contributing Guide
Blog
Where to Get Support
You can help improve the single-spa website by sending pull requests to the `single-spa.js.org` repository.
文档分为以下几个部分:
●	快速开始
●	single-spa 应用程序
●	single-spa 沙箱
●	示例
●	生态系统
●	贡献指南
●	博客
●	帮助与支持
您可以通过向“single-spa.js.org”存储库发送拉取请求（pr）来帮助改进single-spa网站。
简单的用法
# Simple Usage
For a full example, check out this simple webpack example or this starting from scratch tutorial.
To create a single-spa application, you will need to do three things:
1.Create an html file:
```html


<html>
<body>
<script src="single-spa-config.js"></script>
</body>
</html>
```

1.Create a single-spa-config. Check out the docs for more detail.
```js


import * as singleSpa from 'single-spa';
const appName = 'app1';
/* The loading function is a function that returns a promise that resolves with the javascript application module.
* The purpose of it is to facilitate lazy loading -- single-spa will not download the code for a application until it needs to.
* In this example, import() is supported in webpack and returns a Promise, but single-spa works with any loading function that returns a Promise.
*/
const loadingFunction = () => import('./app1/app1.js');
/* single-spa does some top-level routing to determine which application is active for any url. You can implement this routing any way you'd like.
* One useful convention might be to prefix the url with the name of the app that is active, to keep your top-level routing simple.
*/
const activityFunction = location => location.pathname.startsWith('/app1');
singleSpa.registerApplication(appName, loadingFunction, activityFunction);
singleSpa.start();

```
2.Create an application. Check out the docs for more detail.
```js
//app1.js
let domEl;
export function bootstrap(props) {
return Promise
.resolve()
.then(() => {
domEl = document.createElement('div');
domEl.id = 'app1';
document.body.appendChild(domEl);
});
}
export function mount(props) {
return Promise
.resolve()
.then(() => {
// This is where you would normally use a framework to mount some ui to the dom. See https://single-spa.js.org/docs/ecosystem.html.
domEl.textContent = 'App 1 is mounted!'
});
}
export function unmount(props) {
return Promise
.resolve()
.then(() => {
// This is normally where you would tell the framework to unmount the ui from the dom. See https://single-spa.js.org/docs/ecosystem.html
domEl.textContent = '';
})
}
```
要获得完整的示例，请查看这个简单的webpack示例或这个从零开始的教程。
要创建单一spa应用程序，您需要做三件事:
1.创建一个html文件:
```html
<html>
<body>
<script src="single-spa-config.js"></script>
</body>
</html>
```

2.创建一个single-spa-config。查看文档了解更多细节
```js
//main.js
import * as singleSpa from 'single-spa';
const appName = 'app1';
/* loading 是一个返回 promise 的函数，用于 加载/解析 应用代码。
* 它的目的是为延迟加载提供便利 —— single-spa 只有在需要时才会下载应用程序的代码。
* 在这个示例中，在 webpack 中支持 import ()并返回 Promise，但是 single-spa 可以使用任何返回 Promise 的加载函数。
*/
const loadingFunction = () => import('./app1/app1.js');
/* Single-spa 配置顶级路由，以确定哪个应用程序对于指定 url 是激活的。
* 您可以以任何您喜欢的方式实现此路由。
* 一种有用的约定是在url前面加上活动应用程序的名称，以使顶层路由保持简单。
*/
const activityFunction = location => location.pathname.startsWith('/app1');
singleSpa.registerApplication(appName, loadingFunction, activityFunction);
singleSpa.start();

```
3.创建一个应用程序。查看文档了解更多细节。
```js
//app1.js
let domEl;
export function bootstrap(props) {
return Promise
.resolve()
.then(() => {
domEl = document.createElement('div');
domEl.id = 'app1';
document.body.appendChild(domEl);
});
}
export function mount(props) {
return Promise
.resolve()
.then(() => {
// 在这里通常使用框架将ui组件挂载到dom。请参阅https://single-spa.js.org/docs/ecosystem.html。
domEl.textContent = 'App 1 is mounted!'
});
}
export function unmount(props) {
return Promise
.resolve()
.then(() => {
// 在这里通常是通知框架把ui组件从dom中卸载。参见https://single-spa.js.org/docs/ecosystem.html
domEl.textContent = '';
})
}
```

生命周期函数介绍
# API
Read more at single-spa API and application api.
请阅读single-spa API和应用程序API。
贡献
# Contributing
The main purpose of this repository is to continue to evolve single-spa, making it better and easier to use. Development of single-spa, and the single-spa ecosystem happens in the open on GitHub, and we are grateful to the community for contributing bugfixes and improvements. Read below to learn how you can take part in improving single-spa.

这个存储库的主要目的是继续改进single-spa，使其更好、更容易使用。single-spa和single-spa生态系统的开发是在GitHub上开源的，我们非常感谢社区对bug修复和改进的贡献。阅读下面的文章，学习如何参与改善single-spa。
代码规范
# Code of Conduct
single-spa has adopted a Code of Conduct that we expect project participants to adhere to. Please read the full text so that you can understand what actions will and will not be tolerated.

single-spa已经采用了我们希望项目参与者遵守的代码规范。请阅读全文，以便理解什么规范可以被接受，什么规范将被拒绝。
贡献指南
# Contributing Guide
Read our contributing guide to learn about our development process, how to propose bugfixes and improvements, and how to build and test your changes to single-spa.

阅读我们的贡献指南，了解我们的开发过程，如何提出错误修复和改进，以及如何构建和测试对single-spa的更改。
谁在使用？
# Who's Using This?

See user showcase.
Is your company or project using single-spa? Let us know by submitting a PR to this section!

查看用户展示
你的公司或项目是否使用single-spa？通过向本部分提交PR来让我们知道！